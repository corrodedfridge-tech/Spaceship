<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Survivor's Dawn - Infinite Survival</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #000; overflow: hidden; font-family: 'Segoe UI', sans-serif; cursor: none; }
canvas { display: block; }
#ui { position: fixed; top: 0; left: 0; width: 100%; pointer-events: none; z-index: 10; }
#hpBar { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); width: 300px; height: 20px; background: #333; border: 2px solid #555; border-radius: 10px; overflow: hidden; z-index: 10; }
#hpFill { height: 100%; background: linear-gradient(90deg, #ff3333, #ff6666); transition: width 0.2s; border-radius: 10px; }
#xpBar { position: fixed; top: 0; left: 0; width: 100%; height: 8px; background: #1a1a2e; z-index: 10; }
#xpFill { height: 100%; background: linear-gradient(90deg, #00d4ff, #7b2fff); transition: width 0.15s; }
#stats { position: fixed; top: 15px; left: 15px; color: #fff; font-size: 14px; z-index: 10; text-shadow: 1px 1px 3px #000; }
#stats div { margin-bottom: 4px; }
#timer { position: fixed; top: 15px; right: 15px; color: #ffd700; font-size: 22px; font-weight: bold; z-index: 10; text-shadow: 2px 2px 4px #000; }
#killCount { position: fixed; top: 45px; right: 15px; color: #ff6b6b; font-size: 16px; z-index: 10; text-shadow: 1px 1px 3px #000; }
#levelUp { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: none; justify-content: center; align-items: center; z-index: 100; pointer-events: all; cursor: default; }
#levelUpInner { text-align: center; }
#levelUpInner h2 { color: #ffd700; font-size: 36px; margin-bottom: 10px; text-shadow: 0 0 20px #ffd700; }
#levelUpInner p { color: #aaa; margin-bottom: 25px; font-size: 16px; }
#upgradeCards { display: flex; gap: 15px; justify-content: center; flex-wrap: wrap; }
.card { background: linear-gradient(135deg, #1a1a3e, #2a2a5e); border: 2px solid #444; border-radius: 12px; padding: 20px 25px; width: 200px; cursor: pointer; transition: all 0.2s; pointer-events: all; }
.card:hover { border-color: #ffd700; transform: translateY(-5px); box-shadow: 0 5px 25px rgba(255,215,0,0.3); }
.card .icon { font-size: 36px; margin-bottom: 10px; }
.card .name { color: #fff; font-size: 16px; font-weight: bold; margin-bottom: 6px; }
.card .desc { color: #aaa; font-size: 12px; line-height: 1.4; }
#gameOver { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center; z-index: 200; cursor: default; }
#gameOverInner { text-align: center; }
#gameOverInner h2 { color: #ff3333; font-size: 48px; margin-bottom: 15px; text-shadow: 0 0 30px #ff0000; }
#gameOverInner .finalStats { color: #ccc; font-size: 18px; margin-bottom: 30px; line-height: 2; }
#restartBtn { background: linear-gradient(135deg, #ff3333, #ff6666); border: none; color: #fff; font-size: 20px; padding: 12px 40px; border-radius: 8px; cursor: pointer; font-weight: bold; transition: all 0.2s; }
#restartBtn:hover { transform: scale(1.05); box-shadow: 0 5px 20px rgba(255,50,50,0.5); }
#startScreen { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(ellipse at center, #1a0a2e 0%, #000 70%); display: flex; justify-content: center; align-items: center; z-index: 300; cursor: default; }
#startInner { text-align: center; }
#startInner h1 { color: #ffd700; font-size: 52px; margin-bottom: 5px; text-shadow: 0 0 40px rgba(255,215,0,0.5); letter-spacing: 3px; }
#startInner .sub { color: #888; font-size: 16px; margin-bottom: 40px; }
#startBtn { background: linear-gradient(135deg, #7b2fff, #00d4ff); border: none; color: #fff; font-size: 22px; padding: 15px 50px; border-radius: 10px; cursor: pointer; font-weight: bold; transition: all 0.2s; animation: pulse 2s infinite; }
#startBtn:hover { transform: scale(1.08); }
@keyframes pulse { 0%,100% { box-shadow: 0 0 20px rgba(123,47,255,0.4); } 50% { box-shadow: 0 0 40px rgba(0,212,255,0.6); } }
#controls { color: #666; margin-top: 30px; font-size: 13px; line-height: 2; }
#weaponIcons { position: fixed; bottom: 50px; left: 50%; transform: translateX(-50%); display: flex; gap: 8px; z-index: 10; }
.weaponIcon { width: 36px; height: 36px; background: rgba(0,0,0,0.7); border: 2px solid #555; border-radius: 6px; display: flex; align-items: center; justify-content: center; font-size: 18px; }
#dmgNumbers { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9; }
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="xpBar"><div id="xpFill" style="width:0%"></div></div>
<div id="stats">
  <div id="levelDisp">Level: 1</div>
  <div id="weaponList"></div>
</div>
<div id="timer">00:00</div>
<div id="killCount">Kills: 0</div>
<div id="hpBar"><div id="hpFill" style="width:100%"></div></div>
<div id="weaponIcons"></div>

<div id="levelUp">
  <div id="levelUpInner">
    <h2>LEVEL UP!</h2>
    <p>Choose an upgrade</p>
    <div id="upgradeCards"></div>
  </div>
</div>

<div id="gameOver">
  <div id="gameOverInner">
    <h2>YOU DIED</h2>
    <div class="finalStats" id="finalStats"></div>
    <button id="restartBtn" onclick="restartGame()">Try Again</button>
  </div>
</div>

<div id="startScreen">
  <div id="startInner">
    <h1>SURVIVOR'S DAWN</h1>
    <div class="sub">How long can you survive?</div>
    <button id="startBtn" onclick="startGame()">START GAME</button>
    <div id="controls">WASD or Arrow Keys to move<br>Everything else is automatic<br>Survive as long as possible!</div>
  </div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let W, H;
function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
window.addEventListener('resize', resize);
resize();

// Game state
let player, enemies, projectiles, xpOrbs, particles, damageTexts;
let keys = {};
let gameTime, kills, gameRunning, paused, lastTime, spawnTimer;
let camera = { x: 0, y: 0 };
let groundTiles = [];

// Weapon definitions
const WEAPONS = {
  holyWater: { name: 'Holy Water', icon: 'üíß', desc: 'Area damage around you', baseDmg: 8, baseCooldown: 2500, baseArea: 80 },
  fireball: { name: 'Fireball', icon: 'üî•', desc: 'Fires toward nearest enemy', baseDmg: 20, baseCooldown: 1200, baseSpeed: 6, baseArea: 12 },
  lightning: { name: 'Lightning', icon: '‚ö°', desc: 'Strikes random nearby enemy', baseDmg: 30, baseCooldown: 2000, baseRange: 250 },
  orbiter: { name: 'Orbiter', icon: 'üîÆ', desc: 'Orbs rotate around you', baseDmg: 12, baseCooldown: 100, baseCount: 2, baseArea: 100 },
  garlic: { name: 'Garlic Aura', icon: 'üßÑ', desc: 'Damages nearby enemies constantly', baseDmg: 5, baseCooldown: 800, baseArea: 90 },
  knife: { name: 'Throwing Knife', icon: 'üó°Ô∏è', desc: 'Fast projectiles in facing direction', baseDmg: 10, baseCooldown: 600, baseSpeed: 10 },
  whip: { name: 'Whip', icon: 'ü™¢', desc: 'Wide arc attack', baseDmg: 15, baseCooldown: 1400, baseArea: 120 },
  bible: { name: 'Holy Book', icon: 'üìñ', desc: 'Orbits and blocks enemies', baseDmg: 8, baseCooldown: 80, baseCount: 1, baseArea: 130 },
};

const PASSIVE_UPGRADES = {
  maxHp: { name: 'Max HP', icon: '‚ù§Ô∏è', desc: '+20 Max Health', maxLevel: 5 },
  speed: { name: 'Speed', icon: 'üëü', desc: '+8% Movement Speed', maxLevel: 5 },
  armor: { name: 'Armor', icon: 'üõ°Ô∏è', desc: 'Reduce damage by 1', maxLevel: 5 },
  regen: { name: 'Regen', icon: 'üíö', desc: 'Recover 0.5 HP/sec', maxLevel: 5 },
  magnet: { name: 'Magnet', icon: 'üß≤', desc: '+30% Pickup Range', maxLevel: 5 },
  might: { name: 'Might', icon: 'üí™', desc: '+10% Damage', maxLevel: 5 },
  cooldown: { name: 'Cooldown', icon: '‚è±Ô∏è', desc: '-5% Cooldowns', maxLevel: 5 },
  area: { name: 'Area', icon: 'üîµ', desc: '+10% Area', maxLevel: 5 },
};

// Enemy types
const ENEMY_TYPES = [
  { name: 'bat', hp: 15, speed: 1.5, dmg: 5, size: 12, color: '#8866aa', xp: 1 },
  { name: 'zombie', hp: 30, speed: 0.8, dmg: 8, size: 16, color: '#44aa44', xp: 2 },
  { name: 'skeleton', hp: 45, speed: 1.2, dmg: 10, size: 15, color: '#cccccc', xp: 3 },
  { name: 'demon', hp: 80, speed: 1.0, dmg: 15, size: 20, color: '#cc3333', xp: 5 },
  { name: 'wraith', hp: 60, speed: 2.0, dmg: 12, size: 14, color: '#6666ff', xp: 4 },
  { name: 'golem', hp: 200, speed: 0.5, dmg: 25, size: 28, color: '#886633', xp: 10 },
  { name: 'vampire', hp: 150, speed: 1.8, dmg: 20, size: 18, color: '#990066', xp: 8 },
  { name: 'dragon', hp: 500, speed: 0.7, dmg: 35, size: 35, color: '#ff4400', xp: 25 },
];

function initGame() {
  player = {
    x: 0, y: 0, size: 16,
    hp: 100, maxHp: 100,
    speed: 3,
    weapons: [{ type: 'fireball', level: 1, timer: 0 }],
    passives: {},
    xp: 0, xpToNext: 5, level: 1,
    facingX: 1, facingY: 0,
    armor: 0, regen: 0, magnet: 100,
    might: 1, cooldownMult: 1, areaMult: 1,
    invincible: 0,
    animFrame: 0, animTimer: 0,
  };
  enemies = [];
  projectiles = [];
  xpOrbs = [];
  particles = [];
  damageTexts = [];
  gameTime = 0;
  kills = 0;
  spawnTimer = 0;
  gameRunning = true;
  paused = false;
  lastTime = performance.now();
  generateGround();
}

function generateGround() {
  groundTiles = [];
  for (let i = 0; i < 200; i++) {
    groundTiles.push({
      x: (Math.random() - 0.5) * 6000,
      y: (Math.random() - 0.5) * 6000,
      type: Math.random() < 0.6 ? 'grass' : Math.random() < 0.5 ? 'flower' : 'rock',
      size: 3 + Math.random() * 6,
      color: `hsl(${120 + Math.random() * 30}, ${20 + Math.random() * 20}%, ${15 + Math.random() * 15}%)`
    });
  }
}

function startGame() {
  document.getElementById('startScreen').style.display = 'none';
  initGame();
  requestAnimationFrame(gameLoop);
}

function restartGame() {
  document.getElementById('gameOver').style.display = 'none';
  initGame();
}

// Input
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; e.preventDefault(); });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

function gameLoop(now) {
  if (!gameRunning) return;
  requestAnimationFrame(gameLoop);
  
  let dt = Math.min((now - lastTime) / 1000, 0.05);
  lastTime = now;
  
  if (paused) { render(); return; }
  
  gameTime += dt;
  update(dt);
  render();
}

function update(dt) {
  // Player movement
  let mx = 0, my = 0;
  if (keys['w'] || keys['arrowup']) my -= 1;
  if (keys['s'] || keys['arrowdown']) my += 1;
  if (keys['a'] || keys['arrowleft']) mx -= 1;
  if (keys['d'] || keys['arrowright']) mx += 1;
  
  if (mx !== 0 || my !== 0) {
    let len = Math.sqrt(mx*mx + my*my);
    mx /= len; my /= len;
    player.facingX = mx; player.facingY = my;
    player.x += mx * player.speed * 60 * dt;
    player.y += my * player.speed * 60 * dt;
    player.animTimer += dt;
    if (player.animTimer > 0.15) { player.animTimer = 0; player.animFrame = (player.animFrame + 1) % 4; }
  }
  
  // Regen
  if (player.regen > 0) {
    player.hp = Math.min(player.maxHp, player.hp + player.regen * dt);
  }
  
  // Invincibility
  if (player.invincible > 0) player.invincible -= dt;
  
  // Camera
  camera.x = player.x - W/2;
  camera.y = player.y - H/2;
  
  // Spawn enemies
  spawnEnemies(dt);
  
  // Update weapons
  updateWeapons(dt);
  
  // Update projectiles
  updateProjectiles(dt);
  
  // Update enemies
  updateEnemies(dt);
  
  // Update XP orbs
  updateXPOrbs(dt);
  
  // Update particles
  updateParticles(dt);
  
  // Update damage texts
  updateDamageTexts(dt);
  
  // Update UI
  updateUI();
}

function spawnEnemies(dt) {
  let minute = gameTime / 60;
  let spawnRate = Math.max(0.02, 0.5 - minute * 0.03);
  let maxEnemies = Math.min(500, 30 + Math.floor(gameTime * 0.8));
  
  spawnTimer -= dt;
  if (spawnTimer <= 0 && enemies.length < maxEnemies) {
    spawnTimer = spawnRate;
    
    // Determine which enemies can spawn
    let available = [];
    if (minute < 1) available = [0];
    else if (minute < 2) available = [0, 1];
    else if (minute < 3) available = [0, 1, 2];
    else if (minute < 5) available = [0, 1, 2, 3, 4];
    else if (minute < 8) available = [1, 2, 3, 4, 5];
    else if (minute < 12) available = [2, 3, 4, 5, 6];
    else available = [3, 4, 5, 6, 7];
    
    // Spawn count increases over time
    let count = 1 + Math.floor(minute * 0.5);
    
    for (let i = 0; i < count && enemies.length < maxEnemies; i++) {
      let typeIdx = available[Math.floor(Math.random() * available.length)];
      let type = ENEMY_TYPES[typeIdx];
      
      // Spawn off screen
      let angle = Math.random() * Math.PI * 2;
      let dist = Math.max(W, H) * 0.6 + Math.random() * 100;
      let ex = player.x + Math.cos(angle) * dist;
      let ey = player.y + Math.sin(angle) * dist;
      
      // Scale with time
      let hpMult = 1 + minute * 0.15;
      let dmgMult = 1 + minute * 0.08;
      
      enemies.push({
        x: ex, y: ey,
        hp: type.hp * hpMult,
        maxHp: type.hp * hpMult,
        speed: type.speed * (1 + minute * 0.02),
        dmg: type.dmg * dmgMult,
        size: type.size,
        color: type.color,
        xp: type.xp,
        name: type.name,
        hitTimer: 0,
        dmgCooldown: 0,
      });
    }
  }
  
  // Boss spawn every 3 minutes
  if (Math.floor(gameTime) % 180 === 0 && Math.floor(gameTime) > 0 && Math.floor(gameTime) !== Math.floor(gameTime - dt)) {
    let bossType = ENEMY_TYPES[7];
    let angle = Math.random() * Math.PI * 2;
    let dist = Math.max(W, H) * 0.5;
    let bossMult = 1 + minute * 0.3;
    enemies.push({
      x: player.x + Math.cos(angle) * dist,
      y: player.y + Math.sin(angle) * dist,
      hp: bossType.hp * bossMult,
      maxHp: bossType.hp * bossMult,
      speed: bossType.speed,
      dmg: bossType.dmg * bossMult,
      size: bossType.size * 1.5,
      color: '#ff0000',
      xp: bossType.xp * 3,
      name: 'BOSS',
      hitTimer: 0,
      dmgCooldown: 0,
      isBoss: true,
    });
  }
}

function updateWeapons(dt) {
  for (let w of player.weapons) {
    let wDef = WEAPONS[w.type];
    let cd = wDef.baseCooldown * player.cooldownMult / (1 + (w.level - 1) * 0.1);
    w.timer -= dt * 1000;
    
    if (w.timer <= 0) {
      w.timer = cd;
      fireWeapon(w);
    }
  }
}

function fireWeapon(w) {
  let wDef = WEAPONS[w.type];
  let dmg = wDef.baseDmg * player.might * (1 + (w.level - 1) * 0.25);
  let area = (wDef.baseArea || 20) * player.areaMult * (1 + (w.level - 1) * 0.1);
  
  switch(w.type) {
    case 'fireball': {
      let nearest = findNearest(player.x, player.y, 600);
      let count = Math.min(w.level, 5);
      for (let i = 0; i < count; i++) {
        let target = nearest[i % nearest.length];
        if (!target) {
          // Fire in facing direction
          projectiles.push({
            x: player.x, y: player.y,
            vx: player.facingX * wDef.baseSpeed,
            vy: player.facingY * wDef.baseSpeed,
            dmg, size: 8 + w.level, life: 2,
            type: 'fireball', pierce: w.level,
            color: '#ff6600',
          });
        } else {
          let dx = target.x - player.x, dy = target.y - player.y;
          let len = Math.sqrt(dx*dx + dy*dy);
          projectiles.push({
            x: player.x, y: player.y,
            vx: (dx/len) * wDef.baseSpeed,
            vy: (dy/len) * wDef.baseSpeed,
            dmg, size: 8 + w.level, life: 2,
            type: 'fireball', pierce: Math.floor(w.level / 2) + 1,
            color: '#ff6600',
          });
        }
      }
      break;
    }
    case 'holyWater': {
      let count = 1 + Math.floor(w.level / 2);
      for (let i = 0; i < count; i++) {
        let angle = Math.random() * Math.PI * 2;
        let dist = 30 + Math.random() * 100;
        particles.push({
          x: player.x + Math.cos(angle) * dist,
          y: player.y + Math.sin(angle) * dist,
          size: area, life: 1.5, maxLife: 1.5,
          type: 'holyWater', dmg, dmgTimer: 0,
          color: 'rgba(100,150,255,',
        });
      }
      break;
    }
    case 'lightning': {
      let nearest = findNearest(player.x, player.y, (wDef.baseRange || 250) + w.level * 30);
      let targets = Math.min(w.level + 1, nearest.length);
      for (let i = 0; i < targets; i++) {
        let e = nearest[i];
        damageEnemy(e, dmg * 1.5);
        // Lightning visual
        particles.push({
          x: e.x, y: e.y, size: 30,
          life: 0.3, maxLife: 0.3,
          type: 'lightning', color: '#88ddff',
        });
        // Chain
        for (let j = 0; j < 5; j++) {
          particles.push({
            x: player.x + (e.x - player.x) * (j/5) + (Math.random()-0.5)*20,
            y: player.y + (e.y - player.y) * (j/5) + (Math.random()-0.5)*20,
            size: 4, life: 0.2, maxLife: 0.2,
            type: 'spark', color: '#aaeeff',
          });
        }
      }
      break;
    }
    case 'orbiter': {
      // Handled in render - continuous damage
      let orbCount = (wDef.baseCount || 2) + Math.floor(w.level / 2);
      let orbArea = area;
      for (let e of enemies) {
        let dx = e.x - player.x, dy = e.y - player.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < orbArea + e.size) {
          // Check if close to an orb position
          for (let i = 0; i < orbCount; i++) {
            let angle = (gameTime * 2) + (i / orbCount) * Math.PI * 2;
            let ox = player.x + Math.cos(angle) * orbArea;
            let oy = player.y + Math.sin(angle) * orbArea;
            let edx = e.x - ox, edy = e.y - oy;
            if (Math.sqrt(edx*edx + edy*edy) < 25 + e.size) {
              damageEnemy(e, dmg);
              break;
            }
          }
        }
      }
      break;
    }
    case 'garlic': {
      for (let e of enemies) {
        let dx = e.x - player.x, dy = e.y - player.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < area + e.size) {
          damageEnemy(e, dmg);
          // Knockback
          if (dist > 0) {
            e.x += (dx/dist) * 3;
            e.y += (dy/dist) * 3;
          }
        }
      }
      break;
    }
    case 'knife': {
      let count = 1 + Math.floor(w.level / 2);
      for (let i = 0; i < count; i++) {
        let spread = (i - (count-1)/2) * 0.2;
        let cos = Math.cos(spread), sin = Math.sin(spread);
        let vx = player.facingX * cos - player.facingY * sin;
        let vy = player.facingX * sin + player.facingY * cos;
        projectiles.push({
          x: player.x, y: player.y,
          vx: vx * wDef.baseSpeed, vy: vy * wDef.baseSpeed,
          dmg, size: 5, life: 1.5,
          type: 'knife', pierce: 1 + Math.floor(w.level / 3),
          color: '#cccccc',
        });
      }
      break;
    }
    case 'whip': {
      let angle = Math.atan2(player.facingY, player.facingX);
      let arc = Math.PI * 0.6;
      for (let e of enemies) {
        let dx = e.x - player.x, dy = e.y - player.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < area + e.size) {
          let eAngle = Math.atan2(dy, dx);
          let diff = Math.abs(((eAngle - angle + Math.PI * 3) % (Math.PI * 2)) - Math.PI);
          if (diff < arc / 2) {
            damageEnemy(e, dmg);
          }
        }
      }
      // Visual
      particles.push({
        x: player.x, y: player.y,
        angle: angle, arc: arc, radius: area,
        size: area, life: 0.2, maxLife: 0.2,
        type: 'whip', color: '#ffaa44',
      });
      break;
    }
    case 'bible': {
      let bookCount = (wDef.baseCount || 1) + Math.floor(w.level / 2);
      let bookArea = area;
      for (let e of enemies) {
        let dx = e.x - player.x, dy = e.y - player.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < bookArea + e.size + 20) {
          for (let i = 0; i < bookCount; i++) {
            let angle = (gameTime * 3) + (i / bookCount) * Math.PI * 2;
            let bx = player.x + Math.cos(angle) * bookArea;
            let by = player.y + Math.sin(angle) * bookArea;
            let edx = e.x - bx, edy = e.y - by;
            if (Math.sqrt(edx*edx + edy*edy) < 20 + e.size) {
              damageEnemy(e, dmg);
              break;
            }
          }
        }
      }
      break;
    }
  }
}

function findNearest(x, y, range) {
  return enemies
    .filter(e => {
      let dx = e.x - x, dy = e.y - y;
      return Math.sqrt(dx*dx + dy*dy) < range;
    })
    .sort((a, b) => {
      let da = (a.x-x)**2 + (a.y-y)**2;
      let db = (b.x-x)**2 + (b.y-y)**2;
      return da - db;
    });
}

function damageEnemy(e, dmg) {
  e.hp -= dmg;
  e.hitTimer = 0.1;
  
  // Damage text
  damageTexts.push({
    x: e.x + (Math.random()-0.5) * 20,
    y: e.y - e.size,
    text: Math.floor(dmg),
    life: 0.8,
    vy: -2,
    color: dmg > 30 ? '#ffdd00' : '#fff',
    size: dmg > 50 ? 18 : dmg > 25 ? 14 : 11,
  });
  
  if (e.hp <= 0) {
    killEnemy(e);
  }
}

function killEnemy(e) {
  kills++;
  
  // Drop XP
  let orbCount = Math.ceil(e.xp / 2);
  for (let i = 0; i < orbCount; i++) {
    xpOrbs.push({
      x: e.x + (Math.random()-0.5) * 20,
      y: e.y + (Math.random()-0.5) * 20,
      xp: Math.ceil(e.xp / orbCount),
      size: 5 + e.xp * 0.3,
      magnet: false,
    });
  }
  
  // Death particles
  for (let i = 0; i < 6; i++) {
    let angle = Math.random() * Math.PI * 2;
    let speed = 1 + Math.random() * 3;
    particles.push({
      x: e.x, y: e.y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      size: 3 + Math.random() * 4,
      life: 0.4, maxLife: 0.4,
      type: 'death', color: e.color,
    });
  }
  
  e.hp = -999; // Mark for removal
}

function updateProjectiles(dt) {
  for (let i = projectiles.length - 1; i >= 0; i--) {
    let p = projectiles[i];
    p.x += p.vx * 60 * dt;
    p.y += p.vy * 60 * dt;
    p.life -= dt;
    
    if (p.life <= 0) { projectiles.splice(i, 1); continue; }
    
    // Collision with enemies
    for (let e of enemies) {
      if (e.hp <= 0) continue;
      let dx = e.x - p.x, dy = e.y - p.y;
      let dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < e.size + p.size) {
        damageEnemy(e, p.dmg);
        p.pierce--;
        if (p.pierce <= 0) {
          p.life = 0;
          break;
        }
      }
    }
  }
}

function updateEnemies(dt) {
  for (let i = enemies.length - 1; i >= 0; i--) {
    let e = enemies[i];
    if (e.hp <= 0) { enemies.splice(i, 1); continue; }
    
    // Remove if too far
    let dx = e.x - player.x, dy = e.y - player.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    if (dist > 1500) { enemies.splice(i, 1); continue; }
    
    // Move toward player
    if (dist > 0) {
      e.x += (dx / dist) * -e.speed * 60 * dt;
      e.y += (dy / dist) * -e.speed * 60 * dt;
    }
    
    // Simple enemy separation
    for (let j = i + 1; j < enemies.length; j++) {
      let o = enemies[j];
      let sx = e.x - o.x, sy = e.y - o.y;
      let sd = Math.sqrt(sx*sx + sy*sy);
      let minD = e.size + o.size;
      if (sd < minD && sd > 0) {
        let push = (minD - sd) * 0.3;
        e.x += (sx/sd) * push;
        e.y += (sy/sd) * push;
        o.x -= (sx/sd) * push;
        o.y -= (sy/sd) * push;
      }
    }
    
    e.hitTimer = Math.max(0, e.hitTimer - dt);
    e.dmgCooldown = Math.max(0, e.dmgCooldown - dt);
    
    // Damage player
    dx = e.x - player.x; dy = e.y - player.y;
    dist = Math.sqrt(dx*dx + dy*dy);
    if (dist < e.size + player.size && e.dmgCooldown <= 0 && player.invincible <= 0) {
      let finalDmg = Math.max(1, e.dmg - player.armor);
      player.hp -= finalDmg;
      player.invincible = 0.2;
      e.dmgCooldown = 0.5;
      
      damageTexts.push({
        x: player.x, y: player.y - player.size - 10,
        text: Math.floor(finalDmg),
        life: 1, vy: -3,
        color: '#ff3333', size: 16,
      });
      
      if (player.hp <= 0) {
        gameOver();
      }
    }
  }
}

function updateXPOrbs(dt) {
  for (let i = xpOrbs.length - 1; i >= 0; i--) {
    let o = xpOrbs[i];
    let dx = player.x - o.x, dy = player.y - o.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    
    if (dist < player.magnet || o.magnet) {
      o.magnet = true;
      let speed = 8 + (player.magnet - dist) * 0.05;
      o.x += (dx/dist) * speed * 60 * dt;
      o.y += (dy/dist) * speed * 60 * dt;
    }
    
    if (dist < 20) {
      player.xp += o.xp;
      xpOrbs.splice(i, 1);
      
      if (player.xp >= player.xpToNext) {
        levelUp();
      }
    }
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    let p = particles[i];
    p.life -= dt;
    if (p.life <= 0) { particles.splice(i, 1); continue; }
    
    if (p.vx) p.x += p.vx * 60 * dt;
    if (p.vy) p.y += p.vy * 60 * dt;
    
    if (p.type === 'holyWater') {
      p.dmgTimer -= dt;
      if (p.dmgTimer <= 0) {
        p.dmgTimer = 0.3;
        for (let e of enemies) {
          let dx = e.x - p.x, dy = e.y - p.y;
          if (Math.sqrt(dx*dx + dy*dy) < p.size + e.size) {
            damageEnemy(e, p.dmg);
          }
        }
      }
    }
  }
}

function updateDamageTexts(dt) {
  for (let i = damageTexts.length - 1; i >= 0; i--) {
    let t = damageTexts[i];
    t.life -= dt;
    t.y += t.vy;
    if (t.life <= 0) damageTexts.splice(i, 1);
  }
}

function levelUp() {
  player.xp -= player.xpToNext;
  player.level++;
  player.xpToNext = Math.floor(player.xpToNext * 1.4) + 3;
  
  // Heal a bit
  player.hp = Math.min(player.maxHp, player.hp + player.maxHp * 0.1);
  
  paused = true;
  showUpgradeUI();
}

function showUpgradeUI() {
  let options = generateUpgradeOptions();
  let container = document.getElementById('upgradeCards');
  container.innerHTML = '';
  
  for (let opt of options) {
    let card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `<div class="icon">${opt.icon}</div><div class="name">${opt.name} ${opt.level ? 'Lv.' + opt.level : ''}</div><div class="desc">${opt.desc}</div>`;
    card.onclick = () => {
      applyUpgrade(opt);
      document.getElementById('levelUp').style.display = 'none';
      paused = false;
    };
    container.appendChild(card);
  }
  
  document.getElementById('levelUp').style.display = 'flex';
}

function generateUpgradeOptions() {
  let options = [];
  let allOptions = [];
  
  // Existing weapon upgrades
  for (let w of player.weapons) {
    if (w.level < 8) {
      let wDef = WEAPONS[w.type];
      allOptions.push({
        category: 'weapon',
        type: w.type,
        icon: wDef.icon,
        name: wDef.name,
        level: w.level + 1,
        desc: `Upgrade to level ${w.level + 1}`,
      });
    }
  }
  
  // New weapons
  let ownedTypes = player.weapons.map(w => w.type);
  if (player.weapons.length < 6) {
    for (let key of Object.keys(WEAPONS)) {
      if (!ownedTypes.includes(key)) {
        let wDef = WEAPONS[key];
        allOptions.push({
          category: 'newWeapon',
          type: key,
          icon: wDef.icon,
          name: wDef.name,
          level: 1,
          desc: wDef.desc,
        });
      }
    }
  }
  
  // Passive upgrades
  for (let key of Object.keys(PASSIVE_UPGRADES)) {
    let pDef = PASSIVE_UPGRADES[key];
    let currentLvl = player.passives[key] || 0;
    if (currentLvl < pDef.maxLevel) {
      allOptions.push({
        category: 'passive',
        type: key,
        icon: pDef.icon,
        name: pDef.name,
        level: currentLvl + 1,
        desc: pDef.desc,
      });
    }
  }
  
  // Shuffle and pick 3
  allOptions.sort(() => Math.random() - 0.5);
  
  // Prioritize: at least one weapon option if available
  let weaponOpts = allOptions.filter(o => o.category === 'weapon' || o.category === 'newWeapon');
  let otherOpts = allOptions.filter(o => o.category === 'passive');
  
  if (weaponOpts.length > 0) options.push(weaponOpts[0]);
  while (options.length < 3 && otherOpts.length > 0) options.push(otherOpts.shift());
  while (options.length < 3 && weaponOpts.length > options.filter(o=>o.category!=='passive').length) {
    let next = weaponOpts.find(w => !options.includes(w));
    if (next) options.push(next); else break;
  }
  // Fill remaining
  let remaining = allOptions.filter(o => !options.includes(o));
  while (options.length < 3 && remaining.length > 0) options.push(remaining.shift());
  
  return options.slice(0, 3);
}

function applyUpgrade(opt) {
  if (opt.category === 'weapon') {
    let w = player.weapons.find(w => w.type === opt.type);
    if (w) w.level++;
  } else if (opt.category === 'newWeapon') {
    player.weapons.push({ type: opt.type, level: 1, timer: 0 });
  } else if (opt.category === 'passive') {
    player.passives[opt.type] = (player.passives[opt.type] || 0) + 1;
    applyPassive(opt.type);
  }
  
  // Check for additional level ups
  if (player.xp >= player.xpToNext) {
    setTimeout(() => levelUp(), 100);
  }
}

function applyPassive(type) {
  let lvl = player.passives[type];
  switch(type) {
    case 'maxHp': player.maxHp = 100 + lvl * 20; player.hp += 20; break;
    case 'speed': player.speed = 3 * (1 + lvl * 0.08); break;
    case 'armor': player.armor = lvl; break;
    case 'regen': player.regen = lvl * 0.5; break;
    case 'magnet': player.magnet = 100 * (1 + lvl * 0.3); break;
    case 'might': player.might = 1 + lvl * 0.1; break;
    case 'cooldown': player.cooldownMult = 1 - lvl * 0.05; break;
    case 'area': player.areaMult = 1 + lvl * 0.1; break;
  }
}

function updateUI() {
  document.getElementById('hpFill').style.width = (player.hp / player.maxHp * 100) + '%';
  document.getElementById('xpFill').style.width = (player.xp / player.xpToNext * 100) + '%';
  document.getElementById('levelDisp').textContent = 'Level: ' + player.level;
  document.getElementById('killCount').textContent = 'Kills: ' + kills;
  
  let mins = Math.floor(gameTime / 60);
  let secs = Math.floor(gameTime % 60);
  document.getElementById('timer').textContent = String(mins).padStart(2,'0') + ':' + String(secs).padStart(2,'0');
  
  // Weapon icons
  let wIcons = document.getElementById('weaponIcons');
  wIcons.innerHTML = player.weapons.map(w => {
    let def = WEAPONS[w.type];
    return `<div class="weaponIcon" title="${def.name} Lv.${w.level}">${def.icon}</div>`;
  }).join('');
}

function gameOver() {
  gameRunning = false;
  let mins = Math.floor(gameTime / 60);
  let secs = Math.floor(gameTime % 60);
  document.getElementById('finalStats').innerHTML = 
    `Time Survived: ${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}<br>` +
    `Kills: ${kills}<br>` +
    `Level: ${player.level}<br>` +
    `Weapons: ${player.weapons.map(w => WEAPONS[w.type].icon).join(' ')}`;
  document.getElementById('gameOver').style.display = 'flex';
}

// ============ RENDERING ============

function render() {
  ctx.fillStyle = '#0a0a15';
  ctx.fillRect(0, 0, W, H);
  
  ctx.save();
  ctx.translate(-camera.x, -camera.y);
  
  // Ground grid
  drawGround();
  
  // Holy water / area effects
  for (let p of particles) {
    if (p.type === 'holyWater') {
      let alpha = p.life / p.maxLife * 0.4;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fillStyle = p.color + alpha + ')';
      ctx.fill();
    }
  }
  
  // XP orbs
  for (let o of xpOrbs) {
    ctx.save();
    ctx.beginPath();
    ctx.arc(o.x, o.y, o.size, 0, Math.PI * 2);
    let glow = ctx.createRadialGradient(o.x, o.y, 0, o.x, o.y, o.size);
    glow.addColorStop(0, '#00ffaa');
    glow.addColorStop(1, 'rgba(0,255,170,0)');
    ctx.fillStyle = glow;
    ctx.fill();
    ctx.beginPath();
    ctx.arc(o.x, o.y, o.size * 0.5, 0, Math.PI * 2);
    ctx.fillStyle = '#aaffdd';
    ctx.fill();
    ctx.restore();
  }
  
  // Enemies
  for (let e of enemies) {
    if (e.hp <= 0) continue;
    let sx = e.x, sy = e.y, ss = e.size;
    
    // Shadow
    ctx.beginPath();
    ctx.ellipse(sx, sy + ss, ss * 0.7, ss * 0.25, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fill();
    
    // Body
    ctx.save();
    if (e.hitTimer > 0) {
      ctx.fillStyle = '#fff';
    } else {
      ctx.fillStyle = e.color;
    }
    
    // Draw enemy body
    ctx.beginPath();
    ctx.arc(sx, sy, ss, 0, Math.PI * 2);
    ctx.fill();
    
    // Eyes
    ctx.fillStyle = e.hitTimer > 0 ? '#ff0000' : '#ff3333';
    let eyeOff = ss * 0.3;
    ctx.beginPath();
    ctx.arc(sx - eyeOff, sy - ss * 0.15, ss * 0.18, 0, Math.PI * 2);
    ctx.arc(sx + eyeOff, sy - ss * 0.15, ss * 0.18, 0, Math.PI * 2);
    ctx.fill();
    
    // Boss glow
    if (e.isBoss) {
      ctx.beginPath();
      ctx.arc(sx, sy, ss + 5 + Math.sin(gameTime * 5) * 3, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(255,0,0,${0.3 + Math.sin(gameTime * 5) * 0.2})`;
      ctx.lineWidth = 3;
      ctx.stroke();
    }
    
    // HP bar for damaged enemies
    if (e.hp < e.maxHp) {
      let barW = ss * 2;
      let barH = 3;
      ctx.fillStyle = '#333';
      ctx.fillRect(sx - barW/2, sy - ss - 8, barW, barH);
      ctx.fillStyle = e.hp / e.maxHp > 0.5 ? '#44cc44' : e.hp / e.maxHp > 0.25 ? '#cccc44' : '#cc4444';
      ctx.fillRect(sx - barW/2, sy - ss - 8, barW * (e.hp / e.maxHp), barH);
    }
    
    ctx.restore();
  }
  
  // Projectiles
  for (let p of projectiles) {
    ctx.save();
    if (p.type === 'fireball') {
      let glow = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
      glow.addColorStop(0, '#ffff88');
      glow.addColorStop(0.5, '#ff6600');
      glow.addColorStop(1, 'rgba(255,50,0,0)');
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fillStyle = glow;
      ctx.fill();
      // Trail
      for (let t = 1; t <= 3; t++) {
        ctx.beginPath();
        ctx.arc(p.x - p.vx * t * 3, p.y - p.vy * t * 3, p.size * (1 - t*0.25), 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255,100,0,${0.3 - t*0.08})`;
        ctx.fill();
      }
    } else if (p.type === 'knife') {
      ctx.translate(p.x, p.y);
      ctx.rotate(Math.atan2(p.vy, p.vx));
      ctx.fillStyle = '#ddd';
      ctx.beginPath();
      ctx.moveTo(8, 0);
      ctx.lineTo(-4, -3);
      ctx.lineTo(-4, 3);
      ctx.closePath();
      ctx.fill();
    }
    ctx.restore();
  }
  
  // Player
  drawPlayer();
  
  // Orbiter weapons
  for (let w of player.weapons) {
    if (w.type === 'orbiter') {
      let wDef = WEAPONS[w.type];
      let count = (wDef.baseCount || 2) + Math.floor(w.level / 2);
      let area = (wDef.baseArea || 100) * player.areaMult * (1 + (w.level-1)*0.1);
      for (let i = 0; i < count; i++) {
        let angle = (gameTime * 2) + (i / count) * Math.PI * 2;
        let ox = player.x + Math.cos(angle) * area;
        let oy = player.y + Math.sin(angle) * area;
        let glow = ctx.createRadialGradient(ox, oy, 0, ox, oy, 12);
        glow.addColorStop(0, '#ff88ff');
        glow.addColorStop(1, 'rgba(180,50,255,0)');
        ctx.beginPath();
        ctx.arc(ox, oy, 12, 0, Math.PI * 2);
        ctx.fillStyle = glow;
        ctx.fill();
        ctx.beginPath();
        ctx.arc(ox, oy, 5, 0, Math.PI * 2);
        ctx.fillStyle = '#ffaaff';
        ctx.fill();
      }
    }
    if (w.type === 'bible') {
      let wDef = WEAPONS[w.type];
      let count = (wDef.baseCount || 1) + Math.floor(w.level / 2);
      let area = (wDef.baseArea || 130) * player.areaMult * (1 + (w.level-1)*0.1);
      for (let i = 0; i < count; i++) {
        let angle = (gameTime * 3) + (i / count) * Math.PI * 2;
        let bx = player.x + Math.cos(angle) * area;
        let by = player.y + Math.sin(angle) * area;
        ctx.save();
        ctx.translate(bx, by);
        ctx.rotate(gameTime * 5);
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(-6, -8, 12, 16);
        ctx.fillStyle = '#fff';
        ctx.fillRect(-4, -6, 8, 12);
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(-2, -4, 4, 1);
        ctx.fillRect(-1, -5, 2, 3);
        ctx.restore();
      }
    }
    if (w.type === 'garlic') {
      let area = (WEAPONS.garlic.baseArea || 90) * player.areaMult * (1 + (w.level-1)*0.1);
      ctx.beginPath();
      ctx.arc(player.x, player.y, area, 0, Math.PI * 2);
      ctx.strokeStyle = `rgba(200,255,200,${0.15 + Math.sin(gameTime * 3) * 0.1})`;
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }
  
  // Whip visual
  for (let p of particles) {
    if (p.type === 'whip') {
      ctx.save();
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius, p.angle - p.arc/2, p.angle + p.arc/2);
      ctx.lineWidth = 8;
      let alpha = p.life / p.maxLife;
      ctx.strokeStyle = `rgba(255,170,68,${alpha})`;
      ctx.stroke();
      ctx.restore();
    }
  }
  
  // Lightning & spark particles
  for (let p of particles) {
    if (p.type === 'lightning') {
      let alpha = p.life / p.maxLife;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * (1 + (1-alpha) * 2), 0, Math.PI * 2);
      ctx.fillStyle = `rgba(136,221,255,${alpha * 0.5})`;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * 0.5, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.fill();
    }
    if (p.type === 'spark') {
      let alpha = p.life / p.maxLife;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(170,238,255,${alpha})`;
      ctx.fill();
    }
    if (p.type === 'death') {
      let alpha = p.life / p.maxLife;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
      ctx.fillStyle = p.color;
      ctx.globalAlpha = alpha;
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }
  
  // Damage texts
  for (let t of damageTexts) {
    ctx.save();
    ctx.font = `bold ${t.size}px 'Segoe UI', sans-serif`;
    ctx.textAlign = 'center';
    ctx.fillStyle = t.color;
    ctx.globalAlpha = Math.min(1, t.life * 2);
    ctx.fillText(t.text, t.x, t.y);
    ctx.restore();
  }
  
  ctx.restore();
  
  // Minimap
  drawMinimap();
}

function drawGround() {
  // Grid lines
  let gridSize = 100;
  let startX = Math.floor(camera.x / gridSize) * gridSize;
  let startY = Math.floor(camera.y / gridSize) * gridSize;
  
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  ctx.lineWidth = 1;
  for (let x = startX; x < camera.x + W + gridSize; x += gridSize) {
    ctx.beginPath();
    ctx.moveTo(x, camera.y);
    ctx.lineTo(x, camera.y + H);
    ctx.stroke();
  }
  for (let y = startY; y < camera.y + H + gridSize; y += gridSize) {
    ctx.beginPath();
    ctx.moveTo(camera.x, y);
    ctx.lineTo(camera.x + W, y);
    ctx.stroke();
  }
  
  // Ground details
  for (let tile of groundTiles) {
    if (tile.x > camera.x - 50 && tile.x < camera.x + W + 50 &&
        tile.y > camera.y - 50 && tile.y < camera.y + H + 50) {
      ctx.fillStyle = tile.color;
      if (tile.type === 'grass') {
        ctx.fillRect(tile.x, tile.y, tile.size * 0.3, tile.size);
        ctx.fillRect(tile.x + 3, tile.y + 1, tile.size * 0.3, tile.size * 0.8);
      } else if (tile.type === 'flower') {
        ctx.beginPath();
        ctx.arc(tile.x, tile.y, tile.size * 0.4, 0, Math.PI * 2);
        ctx.fillStyle = `hsl(${tile.size * 40}, 60%, 40%)`;
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.arc(tile.x, tile.y, tile.size * 0.5, 0, Math.PI * 2);
        ctx.fillStyle = '#222';
        ctx.fill();
      }
    }
  }
}

function drawPlayer() {
  let px = player.x, py = player.y, ps = player.size;
  
  // Shadow
  ctx.beginPath();
  ctx.ellipse(px, py + ps, ps * 0.7, ps * 0.3, 0, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.fill();
  
  // Invincibility flash
  if (player.invincible > 0 && Math.floor(player.invincible * 20) % 2 === 0) return;
  
  // Body
  ctx.fillStyle = '#4488ff';
  ctx.beginPath();
  ctx.arc(px, py, ps, 0, Math.PI * 2);
  ctx.fill();
  
  // Cape / glow
  ctx.beginPath();
  ctx.arc(px, py, ps + 3, 0, Math.PI * 2);
  ctx.strokeStyle = `rgba(100,150,255,${0.4 + Math.sin(gameTime * 4) * 0.2})`;
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // Inner highlight
  ctx.beginPath();
  ctx.arc(px - ps * 0.2, py - ps * 0.2, ps * 0.6, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(100,180,255,0.3)';
  ctx.fill();
  
  // Eyes
  let eyeX = player.facingX * 3;
  let eyeY = player.facingY * 3;
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(px - 4 + eyeX, py - 3 + eyeY, 3.5, 0, Math.PI * 2);
  ctx.arc(px + 4 + eyeX, py - 3 + eyeY, 3.5, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#112';
  ctx.beginPath();
  ctx.arc(px - 3.5 + eyeX * 1.3, py - 3 + eyeY * 1.3, 2, 0, Math.PI * 2);
  ctx.arc(px + 4.5 + eyeX * 1.3, py - 3 + eyeY * 1.3, 2, 0, Math.PI * 2);
  ctx.fill();
  
  // Level indicator glow
  if (player.level > 5) {
    ctx.beginPath();
    ctx.arc(px, py, ps + 8 + Math.sin(gameTime * 3) * 3, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255,215,0,${0.1 + Math.sin(gameTime * 3) * 0.05})`;
    ctx.lineWidth = 1;
    ctx.stroke();
  }
}

function drawMinimap() {
  let mmSize = 100;
  let mmX = W - mmSize - 15;
  let mmY = H - mmSize - 15;
  let mmScale = 0.03;
  
  ctx.fillStyle = 'rgba(0,0,0,0.5)';
  ctx.fillRect(mmX, mmY, mmSize, mmSize);
  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.strokeRect(mmX, mmY, mmSize, mmSize);
  
  // Enemies on minimap
  ctx.fillStyle = 'rgba(255,50,50,0.7)';
  for (let e of enemies) {
    let ex = mmX + mmSize/2 + (e.x - player.x) * mmScale;
    let ey = mmY + mmSize/2 + (e.y - player.y) * mmScale;
    if (ex > mmX && ex < mmX + mmSize && ey > mmY && ey < mmY + mmSize) {
      ctx.fillRect(ex - 1, ey - 1, 2, 2);
    }
  }
  
  // Player
  ctx.fillStyle = '#4488ff';
  ctx.beginPath();
  ctx.arc(mmX + mmSize/2, mmY + mmSize/2, 3, 0, Math.PI * 2);
  ctx.fill();
}

</script>
</body>
</html>
